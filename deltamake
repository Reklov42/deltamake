#!/usr/bin/env node

const FS = require("fs");
const ReadLine = require("readline");
const ChildProcess = require("child_process");
const Path = require("path");
const process = require("node:process");

/**
 * config
 */
const config = {
	version: "2.1.0",
	project: null,
	solution: null,
	compile: { },
	args: null,
	startPath: "",
	tab: "    ",
	dtab: "        "
};

/**
 * main
 */
async function main() {
	console.log("Delta Make v%s", config.version);

	config.args = ParseArgs();
	if (config.args == null)
		return -1;

	config.startPath = process.cwd();
	if (config.startPath == null)
		return -1;

	const bSolutionConfig = FS.existsSync("solution.json");
	const bProjectConfig = FS.existsSync("project.json");

	if ((bSolutionConfig || bProjectConfig) == false) {
		console.error("ERROR: File \"solution.json\" or \"project.json\" does not exist. Abort");
		return -1;
	}
	else if ((bSolutionConfig || bProjectConfig) == false) {
		console.error("ERROR: Confusion. File \"solution.json\" and \"project.json\" exist in same directory. Abort");
		return -1;
	}

	if (bProjectConfig == true) {
		console.log("Project mode...");
		
		config.project = JSON.parse(FS.readFileSync("project.json", "utf8"));
		if (CheckProjectStruct() == false)
			return -1;

		if (config.args.builds.length == 0)
			config.args.builds.push("default");

		for (let iBuild in config.args.builds) {
			const buildName = config.args.builds[iBuild];
			console.log("Building \"%s\"...", buildName);
			if (CheckProjectBuildStruct(buildName) == false)
				return -1;

			const build = config.project.builds[buildName];
			for (let iSolution in build.solutions) {
				const solutionName = build.solutions[iSolution];
				if (Object.hasOwn(config.project.solutions, solutionName) == false) {
					console.error("ERROR: Solution \"%s\" does not exist. Abort", solutionName);
					return -1;
				}

				console.log("[%s]", solutionName);
				if (ProcessSolution(config.project.solutions[solutionName], config.args.builds) == false) 
					return -1;
			}
		}

		console.log("[Project] Done.");
	}
	else if (bSolutionConfig == true) {
		console.log("Solution mode...");

		return (ProcessSolution("", config.args.builds) == true) ? 0 : -1;
	}
	else {
		console.error("ERROR: Unknown mode. Abort");
		return -1;
	}

	return 0;
}

/**
 * PrintHelp
 */
function PrintHelp() {
	let tmp = "";
	tmp += "Usage:\n";
	tmp += "    deltamake [flags] [build1, build2, ...]\n";
	tmp += "Note:\n";
	tmp += "    If build names are not specified, the \"default\" build name will be used.\n";
	tmp += "flags:\n";
	tmp += "    -h --help\n";
	tmp += "        Show this help text\n";
	tmp += "    -f --force\n";
	tmp += "        Force rebuild all solutions (ignore all pre-builds)\n";
	tmp += "    -n --no-build\n";
	tmp += "        Don't build anything (useful with scan flag)\n";
	tmp += "    -s --scan <code> <headers>\n";
	tmp += "        Scan scanPath for files with specified extensions and save to files and headers lists\n";
	tmp += "        Example usage:\n";
	tmp += "            deltamake -n -s .cpp .h\n";

	console.log(tmp);
}

/**
 * ParseArgs
 */
function ParseArgs() {
	const args = {
		bForce: false,
		bScan: false,
		codeFilter: "",
		headerFilter: "",
		bNoBuild: false,
		builds: [],
	};

	for (let i = 2; i < process.argv.length; ++i) {
		if (process.argv[i].startsWith("-")) {
			switch (process.argv[i].slice(1)) {
				case "h":
				case "-help":
					PrintHelp();
					return null;
				case "f":
				case "-force":
					args.bForce = true;
					break;
				case "s":
				case "-scan":
					if ((i + 3) > process.argv.length) {
						console.error("Not enough arguments to scan. Use -h flag for help. Abort");
						return null;
					}
					
					args.codeFilter = process.argv[++i];
					args.headerFilter = process.argv[++i];

					args.bScan = true;
					break;
				case "n":
				case "-no-build":
					args.bNoBuild = true;
					break;

				default:
					console.error("Unknown flag \"%s\". Use -h flag for help. Abort", process.argv[i]);
					return null;
			}
		}
		else {
			args.builds.push(process.argv[i]);
		}
	}

	return args;
}

/**
 * ScanDirectory
 */
function ScanDirectory(path) {
	return FS.readdirSync(path).reduce((files, file) => {
			const name = Path.join(path, file);
			const isDirectory = FS.statSync(name).isDirectory();
			return isDirectory ? [...files, ...ScanDirectory(name)] : [...files, name];
		},
		[]
	);
}

/**
 * CheckProjectStruct
 */
function CheckProjectStruct() {
	const table = [
		"version",
		"solutions",
		"builds"
	];

	for (let i = 0; i < table.length; ++i) {
		if (Object.hasOwn(config.project, table[i]) == false) {
			console.error("ERROR: \"%s\" value does not exist in project file. Abort", table[i]);
			return false;
		}
	};

	if (config.project.version != config.version) {
		console.error("ERROR: File version \"" + config.project.version + "\" not supported. Abort.")
		return false;
	}

	return true;
}

/**
 * CheckProjectBuildStruct
 */
function CheckProjectBuildStruct(buildname) {
	if (Object.hasOwn(config.project.builds, buildname) == false) {
		console.error("ERROR: build \"%s\" does not exist in project. Abort", buildname);
		return false;
	}
	
	const build = config.project.builds[buildname];

	let table = [
		"solutions"
	];

	for (let i = 0; i < table.length; ++i) {
		if (Object.hasOwn(build, table[i]) == false) {
			console.error("ERROR: \"%s\" value does not exist in project build. Abort", table[i]);
			return false;
		}
	};

	return true;
}

/**
 * CheckSolutonStruct
 */
function CheckSolutonStruct() {
	const table = [
		"version",
		"scanPath",
		"buildPath",
		"tmpPath",
		"files",
		"headers",
		"builds"
	];

	for (let i = 0; i < table.length; ++i) {
		if (Object.hasOwn(config.solution, table[i]) == false) {
			console.error("ERROR: \"%s\" value does not exist in solution file. Abort", table[i]);
			return false;
		}
	};

	if (config.solution.version != config.version) {
		console.error("ERROR: File version \"" + config.solution.version + "\" not supported. Abort.")
		return false;
	}

	return true;
}

/**
 * CheckSolutonBuildStruct
 */
function CheckSolutonBuildStruct(buildname) {
	if (Object.hasOwn(config.solution.builds, buildname) == false) {
		console.error("ERROR: build \"%s\" does not exist in solution. Abort", buildname);
		return false;
	}
	
	const build = config.solution.builds[buildname];
	if (Object.hasOwn(build, "type") == false) {
		console.error("ERROR: \"type\" value does not exist in solution build. Abort");
		return false;
	}

	let table = [
		"type",
		"outname"
	];

	if (build.type == "exec") {
		table.concat([
            "includePaths",
            "defines",
			"libPaths",
            "compiler",
            "compilerFlags",
            "linker",
            "linkerFlags",
			"staticLibs"
		]);
	}
	else if (build.type == "lib") {
		table.concat([
            "includePaths",
            "defines",
			"libPaths",
            "compiler",
            "compilerFlags",
            "archiver",
			"staticLibs"
		]);
	}

	for (let i = 0; i < table.length; ++i) {
		if (Object.hasOwn(build, table[i]) == false) {
			console.error("ERROR: \"%s\" value does not exist in solution build. Abort", table[i]);
			return false;
		}
	};

	return true;
}

/**
 * ProcessSolution
 */
function ProcessSolution(path, builds) {
	console.log("Moving to \"%s\"...", path);
	process.chdir(config.startPath + "/" + path);

	if (FS.existsSync("solution.json") == false) {
		console.error("ERROR: File \"solution.json\" does not exist. Abort");
		return false;
	}

	config.solution = JSON.parse(FS.readFileSync("solution.json", "utf8"));
	if (CheckSolutonStruct() == false)
		return false;

	if (FS.existsSync("compile.json") == true)
		config.compile = JSON.parse(FS.readFileSync("compile.json", "utf8"));


	if (config.args.bScan == true) {
		console.log("Scaning \"%s\"...", config.solution.scanPath);

		let files = ScanDirectory(config.solution.scanPath);
		let code = files.filter((path) => path.endsWith(config.args.codeFilter));
		let header = files.filter((path) => path.endsWith(config.args.headerFilter));
		
		config.solution.files = code;
		config.solution.headers = header;

		console.log(config.tab + "Code files:");
		code.forEach((path) => { console.log(config.dtab + path) });

		console.log(config.tab + "Header files:");
		header.forEach((path) => { console.log(config.dtab + path) });
	}

	if (builds.length == 0)
		builds.push("default");

	if (config.args.bNoBuild == true)
		builds = [ ];
	
	for (let iBuild in builds) {
		const buildName = builds[iBuild];
		console.log("Building \"%s\"...", buildName);
		if (CheckSolutonBuildStruct(buildName) == false)
			return false;
		
		if (Object.hasOwn(config.compile, buildName) == false)
			config.compile[buildName] = { }

		let toCompile = [];
		if (config.args.bForce == true) {
			config.solution.files.forEach((path) => {
				toCompile.push({
					path: path,
					mtime: FS.statSync(path).mtime.getTime()
				});
			});
		}
		else {
			config.solution.files.forEach((path) => {
				const mtime = FS.statSync(path).mtime.getTime();
				if (Object.hasOwn(config.compile[buildName], path) == false)
					config.compile[buildName][path] = 0;

				if (mtime > config.compile[buildName][path]) {
					toCompile.push({
						path: path,
						mtime: mtime
					});
				}
			});
		}

		if (toCompile.length == 0) {
			console.log("Nothing to do.");
			return true;
		}
	
		/*
		const blank = "\r" + " ".repeat(process.stdout.columns) + "\r";
		for (let i = 0; i < toCompile.length; ++i) {
			process.stdout.write(blank);
			CompileObject(build, toCompile[i]);
			process.stdout.write("[" + "=".repeat(i + 1) + " ".repeat(toCompile.length - i - 1) + "]");
		}
		console.log(blank);
		*/

		let bAr = false;
		switch (config.solution.builds[buildName].type) {
			case "exec":
				break;
			case "lib":
				bAr = true;
				break;
			default:
				console.log("ERROR: unknown type \"%s\" in solution build. Abort", config.solution.builds[buildName].type);
				return false;
		}

		console.log(config.tab + "Compiling...");
		for (let i = 0; i < toCompile.length; ++i) {
			const p = Math.floor((i + 1) / toCompile.length * 20);
			process.stdout.write(config.dtab + "[" + "=".repeat(p) + ".".repeat(20 - p) + "] " );

			CompileObject(buildName, toCompile[i]);
		}

		let linkObjects = [];
		for (let i = 0; i < config.solution.files.length; ++i)
			linkObjects.push(config.solution.files[i].split('/').pop().split('.')[0])

		if (bAr == false) {
			console.log(config.tab + "Linking exec...");

			process.stdout.write(config.dtab);
			LinkExec(buildName, linkObjects);
		}
		else {
			console.log(config.tab + "Archiving...");
			let objects = [];
			for (let i = 0; i < config.solution.files.length; ++i)
				objects.push(config.solution.files[i].split('/').pop().split('.')[0])

			process.stdout.write(config.dtab);
			ArchiveObjects(buildName, objects);
		}

		for (let i = 0; i < toCompile.length; ++i)
			config.compile[buildName][toCompile[i].path] = toCompile[i].mtime;

		console.log("Done.");
	}

	try {
		FS.writeFileSync("solution.json", JSON.stringify(config.solution, null, 4), "utf8");
	} catch (error) {
		console.error("ERROR: " + error);
	}

	try {
		FS.writeFileSync("compile.json", JSON.stringify(config.compile, null, 4), "utf8");
	} catch (error) {
		console.error("ERROR: " + error);
	}

	return true;
}

/**
 * System
 */
function System(command) {
	console.log(command);
	try {
		ChildProcess.execSync(command);
	} 
	catch (error) {
		//console.log("error.stderr", error.stderr.toString()); // error.status error.message error.stderr error.stdout
		process.exit(-1);
	}

	return;
	ChildProcess.exec(command, { encoding: "buffer"}, (error, stdout, stderr) => {
		console.log();
		if (stdout.length != 0) console.log(stdout);
		if (stderr.length != 0) console.log(stderr);
		if (error) {
			console.log(error)
			process.exit(-1);
		}
	});
}

/**
 * CompileObject
 */
function CompileObject(buildName, sc) {
	const build = config.solution.builds[buildName];
	const path = sc.path;
	const name = path.split('/').pop().split('.')[0];
	//console.log("Compiling \"%s\"...", name);

	let command = build.compiler + " " + build.compilerFlags;
	build.includePaths.forEach((path) => { command += " -I\"" + path + "\""; });
	build.libPaths.forEach((path) => { command += " -L\"" + path + "\""; });
	build.defines.forEach((def) => { command += " -D\"" + def + "\""; });

	command += " -c \"" + path + "\" -o \"" + config.solution.tmpPath + buildName + "_" + name + "\"";
	System(command);
}

/**
 * LinkExec
 */
function LinkExec(buildName, objects) {
	const build = config.solution.builds[buildName];
	let command = build.linker + " " + build.linkerFlags;

	objects.forEach((obj) => { command += " \"" + config.solution.tmpPath + buildName + "_" + obj + "\""; });
	build.staticLibs.forEach((lib) => { command += " " + lib; });
		
	command += " -o \"" + config.solution.buildPath + build.outname + "\"";;
	System(command);
}

/**
 * ArchiveObjects
 */
function ArchiveObjects(buildName, objects) {
	const build = config.solution.builds[buildName];
	let command = build.archiver + " " + "rcs " + config.solution.buildPath + build.outname;
	objects.forEach((obj) => { command += " " + config.solution.tmpPath + buildName + "_" + obj; });

	System(command);
}

/**
 *
 */
(async () => {
	process.exit(await main());
})();